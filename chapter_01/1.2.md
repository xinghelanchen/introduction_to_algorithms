# 练习1.2

### 1.2-1 给出在应用层需要算法内容的应用的一个例子，并讨论涉及的算法的功能。

1. 这里的应用层应该指的不是计算机网络中的那个[应用层](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82)了，指的应该是实际生活中使用的应用软件，这样的话，在常用的Excel中的排序操作就是算法一个体现了。

2. [排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)：是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。那么在Excel中的使用就是为了将某一列或者某几列按照一定的顺序排列起来用于更加方面的观察出需要的信息。

### 1.2-2 假设我们正比较插入排序与归并排序在相同机器上的实现。对规模为n的输入，插入排序运行8*n^2步，而归并排序运行64nlgn步。问对哪些n值，插入排序优于归并排序？

1. 因为机器相同所以计算过程中的每一步耗时都是相同的：
    ```
    8 * n ^ 2 < 64 * n * lgn
    =>      n < 8 * lgn
    
    因为1的时候上述等式不成立，所以代码从2开始
    
    java代码：
    public static void main(String[] args) {
        double d1;
        double d2;
        for (int i = 2; i < 100; i++) {
            d1 = 8 * i * i;
            d2 = 64 * i * Math.log10(i);
            if (d1 < d2) {
                System.out.println(i);
            } else {
                System.out.println("final");
                break;
            }
        }
    }
    
    可知结果为2，3，4，5，6
    ```
    
### 1.2-3 n的最小值为何值时，运行时间为100*n^2的一个算法在相同机器上快于运行时间为2^n的另一个算法？

1. 因为机器相同所以计算过程中的每一步耗时都是相同的：
    ```
    java代码：
    public static void main(String[] args) {
        double d1;
        double d2;
        for (int i = 1; i < 100; i++) {
            d1 = 100 * i * i;
            d2 = 2 << (i - 1);
            if (d1 < d2) {
                System.out.println(i);
                break;
            }
        }
    }
    
    所以答案是：15
    ```

### 思考题 1-1

1. （运行时间的比较）假设求解问题的算法需要 f(n) 毫秒，对下表中的每个函数 f(n) 和时间 t ，确定可以在时间t内求解的问题的最大规模 n 。

   这里直接引用 CSDN 上面的一篇博客，原文链接：[算法导论-第一部分-读书笔记](https://blog.csdn.net/hotdust/article/details/79380749)

   先把 1 秒钟转换为 1000 毫秒，和 f(n) 单位一致，然后求解 1000/(lgn) <= 1 这个公式即可，以此类推。
|  | 1秒钟  | 1分钟 | 1小时 | 1天 | 1月 | 1年 | 1世纪 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| $ \lg n $ | 2^1000 | 2^60000 | 正无穷大 | 正无穷大 | 正无穷大 | 正无穷大 | 正无穷大 |
| $ \sqrt{ n} $ | 10^6 | 4.29E+9 | 1.76E+13 | 9.01E+15 |  |  |  |
| $ n $ | 1000 | 60000 | 3600000 | 8640000 | 259000000 | 31104000000 | 3110400000000 |
| $ n ^ 2 $ | 141 | 4896 | 204095 | 3.94E+6 |  |  |  |
| $ n ^ 2 $ | 32 | 245 | 1898 | 8296 | 50912 | 177584 | 1775838 |
| $ n ^ 2 $ | 11 | 40 | 113 | 443 | 638 | 3145 | 14598 |
| $ n ^ 2 $ | 10 | 16 | 22 | 27 | 32 | 35 | 42 |
| $ n ! $ | 7 | 9 | 10 | 12 | 15 | 17 | 18 |

​	以上结果均为摘录原文，这个题的目的在于直观的展示出来不同算法复杂度的差异